# Design: Unified Mocking with oRPC, OpenAPI, Kubb, and MSW

This document outlines the design for a unified, type-safe, and automated API/IPC mocking infrastructure. The core principle is to leverage oRPC's native OpenAPI support to create a standardized testing environment that is compatible with MSW (Mock Service Worker).

## 1. Core Architecture: From IPC to HTTP

The primary challenge in testing our frontend components is their dependence on the Electron IPC communication channel, which is not natively understood by standard testing tools.

This design overcomes this by re-configuring the oRPC client's transport layer based on the environment:

*   **In Production**: The `oRPC` client will continue to use `@orpc/client/message-port`'s `RPCLink` to communicate over the highly efficient Electron IPC channel.
*   **In Test (`NODE_ENV === 'test'`)**: The `oRPC` client will be configured to use a standard `HTTPLink`. All oRPC procedure calls will be automatically translated into standard `POST` requests to a predictable URL structure (e.g., `http://localhost/rpc/app.checkForUpdates`).

This simple, conditional switch is the lynchpin of the entire strategy. It makes our application's communication layer understandable to MSW without changing any component-level code.

## 2. Automated Mock Generation: The Kubb Pipeline

Instead of manually writing MSW handlers, we will automate their creation to ensure they are always type-safe and in sync with our API contract. We will leverage the following Kubb plugins:

*   **`@kubb/core`**: The main engine for Kubb.
*   **`@kubb/cli`**: The command-line interface to run Kubb.
*   **`@kubb/swagger`**: The core plugin for reading and parsing OpenAPI v2 or v3 specifications.
*   **`@kubb/swagger-ts`**: Generates TypeScript types and interfaces from the OpenAPI schema. This is essential for strong type-checking.
*   **`@kubb/swagger-zod`**: Generates Zod schemas for runtime validation of API responses. Highly recommended for robust data handling.
*   **`@kubb/swagger-msw`**: Generates MSW request handlers for each API endpoint. This is our primary mocking output.
*   **`@kubb/swagger-faker`**: Generates fake data using Faker.js based on the OpenAPI schema, useful for test data and Storybook demos. This is also highly recommended.

This will be achieved through the following pipeline:

1.  **Schema Export**: An npm script (`pnpm openapi:generate`) will be added to execute a script that imports our main `AppRouter` from `src/main/ipc/router.ts` and uses `@orpc/server` utilities to generate an `openapi.json` file. This file is the machine-readable "contract" of our API.

2.  **Code Generation with Kubb**:
    *   The project will be configured with a `kubb.config.ts` file.
    *   Kubb will read `openapi.json` and generate files, e.g., `test/mocks/gen/handlers.ts` (for MSW handlers), `src/types/gen/api.d.ts` (for TypeScript types), and `src/schemas/gen/api.ts` (for Zod schemas).

    **Example Generated MSW Handler (Conceptual):**
    ```typescript
    // This file is auto-generated by Kubb
    // test/mocks/gen/handlers.ts
    import { http, HttpResponse } from 'msw';
    import type { AppCheckForUpdatesResponse } from '@/types/gen/api'; // From @kubb/swagger-ts

    export const getAppCheckForUpdatesHandler = (resolver: (
      args: { body: any; pathParams: any; queryParams: any }
    ) => HttpResponse<AppCheckForUpdatesResponse>) =>
      http.post('/rpc/app/checkForUpdates', resolver);
    ```
    (Note: The `getAppCheckForUpdatesHandler` signature and usage might differ slightly based on Kubb's exact output, but the concept of a type-safe handler is the same.)

    > [!IMPORTANT]
    > A critical prerequisite for this pipeline is that all oRPC handlers in `src/main/ipc/` must have explicit Zod schemas defined for both their `input` and `output` using the `.input()` and `.output()` methods. Without these explicit schemas, the oRPC server cannot generate a sufficiently detailed OpenAPI specification, and Kubb will fail to produce meaningful, typed mocks.

    (Regarding custom plugins like `@kubb/plugin-mcp` you mentioned earlier: while a plugin with this exact name does not exist, Kubb's architecture is highly extensible, allowing for the development of custom plugins to generate code for specific protocols or tools, demonstrating its flexibility.)

## 3. TypeScript Configuration Strategy

A key challenge is ensuring that our TypeScript compiler (`tsc -b`) can holistically validate all source code, including `src`, `test`, `scripts`, and Kubb-generated mock files, without conflicts arising from Kubb's generated import paths (which include `.ts` extensions). We leverage TypeScript's project references and separate `tsconfig` files to achieve this:

1.  **Existing `tsconfig.vitest.json`**: This file, located at the project root, already includes `test/**/*.ts` and is configured for Vitest's environment (e.g., JSDOM types). To allow it to correctly process Kubb-generated files, we will modify it to include:
    *   `"noEmit": true`: This tells the TypeScript compiler to only perform type checking and not generate any JavaScript output for files covered by this `tsconfig`.
    *   `"allowImportingTsExtensions": true`: Since `noEmit` is set, this option can be safely enabled, allowing `tsc` to correctly resolve import paths that include `.ts` extensions (e.g., `import './foo.ts'`).

2.  **Existing `tsconfig.playwright.json`**: This file, also at the project root, is specifically for Playwright E2E tests and includes `test/e2e/**/*.ts`. It does not require any specific modifications for Kubb-generated code, as E2E tests will not typically import generated mocks directly.

3.  **Root `tsconfig.json`**: The root `tsconfig.json` will be updated to act as a central orchestrator. It will include references to:
    *   `src/main`, `src/preload`, `src/renderer` (for application modules).
    *   `./tsconfig.vitest.json` (for all Vitest-related test files, including generated mocks).
    *   `./tsconfig.playwright.json` (for Playwright E2E test files).

This holistic strategy ensures that `pnpm tsc -b` can run across the entire project, with each part being type-checked according to its specific needs, without conflicts between production builds and test-specific type checking.

## 4. Toolchain Integration

The single set of auto-generated handlers will be consumed by our primary testing tools, providing a single source of truth for mocking.

*   **Vitest**:
    *   A central `test/mocks/server.ts` file will use `setupServer` from `msw/node` to create a Node.js-compatible mock server.
    *   A global `test/vitest.setup.ts` file will import this server and manage its lifecycle (`listen`, `resetHandlers`, `close`), making API mocking automatically available in all Vitest test files.

*   **Storybook**:
    *   The `msw-storybook-addon` will be installed.
    *   The `.storybook/preview.ts` file will be configured with the `mswLoader`.
    *   Individual stories will use the `parameters.msw.handlers` property to declaratively specify which auto-generated Kubb handlers are needed for that specific story.

## 5. A Note on End-to-End Testing

After initial analysis, we have made a strategic decision **not** to integrate MSW with our Playwright End-to-End (E2E) tests.

E2E tests provide the most value when they verify the complete, integrated application with as few mocks as possible. Their purpose is to simulate a real user's experience. Mocking the API layer at this stage would diminish the confidence these tests provide. Instead, component-level and integration tests (via Vitest and Storybook) will be the primary places where we use MSW to test our UI against a wide variety of mocked API states.

## 6. New OpenSpec: `msw-integration`

A new, dedicated OpenSpec document, `msw-integration/spec.md`, will be created to formally define the architecture, setup, and usage guidelines for MSW within the project. This spec will cover:
*   The overall philosophy of contract-based mocking with MSW.
*   Detailed setup instructions for Vitest and Storybook.
*   Guidelines for using Kubb-generated handlers.
*   Best practices for writing MSW handlers and scenarios.
*   The TypeScript configuration strategy that enables the tooling to work.
