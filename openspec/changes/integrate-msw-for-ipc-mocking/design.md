# Design: Unified Mocking with oRPC, OpenAPI, Kubb, and MSW

This document outlines the design for a unified, type-safe, and automated API/IPC mocking infrastructure. The core principle is to leverage oRPC's native OpenAPI support to create a standardized testing environment that is compatible with MSW (Mock Service Worker).

## 1. Core Architecture: From IPC to HTTP

The primary challenge in testing our frontend components is their dependence on the Electron IPC communication channel, which is not natively understood by standard testing tools.

This design overcomes this by re-configuring the oRPC client's transport layer based on the environment:

*   **In Production**: The `oRPC` client will continue to use `@orpc/client/message-port`'s `RPCLink` to communicate over the highly efficient Electron IPC channel.
*   **In Test (`NODE_ENV === 'test'`)**: The `oRPC` client will be configured to use a standard `HTTPLink`. All oRPC procedure calls will be automatically translated into standard `POST` requests to a predictable URL structure (e.g., `http://localhost/rpc/app.checkForUpdates`).

This simple, conditional switch is the lynchpin of the entire strategy. It makes our application's communication layer understandable to MSW without changing any component-level code.

## 2. Automated Mock Generation: The Kubb Pipeline

Instead of manually writing MSW handlers, we will automate their creation to ensure they are always type-safe and in sync with our API contract. We will leverage the following Kubb plugins:

*   **`@kubb/core`**: The main engine for Kubb.
*   **`@kubb/cli`**: The command-line interface to run Kubb.
*   **`@kubb/swagger`**: The core plugin for reading and parsing OpenAPI v2 or v3 specifications.
*   **`@kubb/swagger-ts`**: Generates TypeScript types and interfaces from the OpenAPI schema. This is essential for strong type-checking.
*   **`@kubb/swagger-zod`**: Generates Zod schemas for runtime validation of API responses. Highly recommended for robust data handling.
*   **`@kubb/swagger-msw`**: Generates MSW request handlers for each API endpoint. This is our primary mocking output.
*   **`@kubb/swagger-faker`**: Generates fake data using Faker.js based on the OpenAPI schema, useful for test data and Storybook demos. This is also highly recommended.

This will be achieved through the following pipeline:

1.  **Schema Export**: An npm script (`pnpm openapi:generate`) will be added to execute a script that imports our main `AppRouter` from `src/main/ipc/router.ts` and uses `@orpc/server` utilities to generate an `openapi.json` file. This file is the machine-readable "contract" of our API.

2.  **Code Generation with Kubb**:
    *   The project will be configured with a `kubb.config.ts` file.
    *   Kubb will read `openapi.json` and generate files, e.g., `test/mocks/gen/handlers.ts` (for MSW handlers), `src/types/gen/api.d.ts` (for TypeScript types), and `src/schemas/gen/api.ts` (for Zod schemas).

    **Example Generated MSW Handler (Conceptual):**
    ```typescript
    // This file is auto-generated by Kubb
    // test/mocks/gen/handlers.ts
    import { http, HttpResponse } from 'msw';
    import type { AppCheckForUpdatesResponse } from '@/types/gen/api'; // From @kubb/swagger-ts

    export const getAppCheckForUpdatesHandler = (resolver: (
      args: { body: any; pathParams: any; queryParams: any }
    ) => HttpResponse<AppCheckForUpdatesResponse>) =>
      http.post('/rpc/app/checkForUpdates', resolver);
    ```
    (Note: The `getAppCheckForUpdatesHandler` signature and usage might differ slightly based on Kubb's exact output, but the concept of a type-safe handler is the same.)

    (Regarding custom plugins like `@kubb/plugin-mcp` you mentioned earlier: while a plugin with this exact name does not exist, Kubb's architecture is highly extensible, allowing for the development of custom plugins to generate code for specific protocols or tools, demonstrating its flexibility.)

## 3. Toolchain Integration

The single set of auto-generated handlers will be consumed by all our testing tools, providing a single source of truth for mocking. The detailed integration for each tool will be documented in the new `msw-integration` OpenSpec.

*   **Vitest**:
    *   A central `test/mocks/server.ts` file will use `setupServer` from `msw/node` to create a Node.js-compatible mock server.
    *   A global `test/vitest.setup.ts` file will import this server and manage its lifecycle (`listen`, `resetHandlers`, `close`), making API mocking automatically available in all Vitest test files.

*   **Storybook**:
    *   The `msw-storybook-addon` will be installed.
    *   The `.storybook/preview.ts` file will be configured with the `mswLoader`.
    *   Individual stories will use the `parameters.msw.handlers` property to declaratively specify which auto-generated Kubb handlers are needed for that specific story, providing a clean, readable, and powerful way to test components in different states.

*   **Playwright**:
    *   The `playwright-msw` library (or a similar solution) will be investigated and implemented.
    *   The goal is to import the same Kubb-generated handlers directly into Playwright E2E tests, allowing us to fully control the application's backend responses even during full, end-to-end test runs. This is invaluable for creating stable tests for features like the update flow.

This unified design ensures that a change in our API contract (a new oRPC procedure) will, after running the generation scripts, immediately result in updated, type-safe mock handlers being available across our entire testing ecosystem.

## 4. New OpenSpec: `msw-integration`

A new, dedicated OpenSpec document, `msw-integration/spec.md`, will be created to formally define the architecture, setup, and usage guidelines for MSW within the project. This spec will cover:
*   The overall philosophy of contract-based mocking with MSW.
*   Detailed setup instructions for Vitest, Storybook, and Playwright.
*   Guidelines for using Kubb-generated handlers.
*   Best practices for writing MSW handlers and scenarios.
